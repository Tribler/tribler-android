/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// This string is autogenerated by ChangeAppSettings.sh, do not change spaces amount
package org.renpy.android;

import android.content.Context;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.os.PowerManager;
import android.util.Log;
import android.view.SurfaceHolder;
import android.view.SurfaceView;


public class SDLSurfaceView extends SurfaceView implements SurfaceHolder.Callback, Runnable {
    static private final String TAG = "SDLSurface";
    static private final boolean DEBUG = false;  

    // The activity we're a part of.
    private static PythonActivity mActivity;

    // Have we started yet?
    public boolean mStarted = false;

    // Has the display been changed?
    private boolean mChanged = false;

    // Are we running yet?
    private boolean mRunning = false;

    // The user program is not participating in the pause protocol.
    static int PAUSE_NOT_PARTICIPATING = 0;

    // A pause has not been requested by the OS.
    static int PAUSE_NONE = 1;

    // A pause has been requested by Android, but the user program has
    // not bothered responding yet.
    static int PAUSE_REQUEST = 2;

    // The user program is waiting in waitForResume.
    static int PAUSE_WAIT_FOR_RESUME = 3;

    static int PAUSE_STOP_REQUEST = 4;
    static int PAUSE_STOP_ACK = 5;

    // This stores the state of the pause system.
    static int mPause = PAUSE_NOT_PARTICIPATING;

    private PowerManager.WakeLock wakeLock;

    // The name of the directory where the context stores its files.
    String mFilesDirectory = null;

    // The value of the argument passed in.
    String mArgument = null;

    // Access to our meta-data
    private ApplicationInfo ai;

    public SDLSurfaceView(PythonActivity act, String argument) {
        super(act);

        mActivity = act;

        SurfaceHolder holder = getHolder();
        holder.addCallback(this);
        holder.setType(SurfaceHolder.SURFACE_TYPE_GPU);

        mFilesDirectory = mActivity.getFilesDir().getAbsolutePath();
        mArgument = argument;

        PowerManager pm = (PowerManager) act.getSystemService(Context.POWER_SERVICE);

        wakeLock = null;
        try {
            ai = act.getPackageManager().getApplicationInfo(
                    act.getPackageName(), PackageManager.GET_META_DATA);
            if ( (Integer)ai.metaData.get("wakelock") == 1 ) {
                wakeLock = pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK, "Screen On");
            }
        } catch (PackageManager.NameNotFoundException e) {
        }
    }


    /**
     * The user program should call this frequently to check if a
     * pause has been requested by android. If this ever returns
     * true, the user program should clean up and call waitForResume.
     * Don't remove this function (needed for nativeInitJavaCallBacks)
     */
    public int checkPause() {
        if (mPause == PAUSE_NOT_PARTICIPATING) {
            mPause = PAUSE_NONE;
        }

        if (mPause == PAUSE_REQUEST) {
            return 1;
        } else {
            return 0;
        }
    }


    /**
     * The user program should call this quickly after checkPause
     * returns true. This causes the android application to sleep,
     * waiting for resume. While sleeping, it should not have any
     * activity. (Notably, it should stop all timers.)
     *
     * While we're waiting in this method, android is allowed to
     * kill us to reclaim memory, without any further warning.
     */
    public void waitForResume() {
        synchronized (this) {
            mPause = PAUSE_WAIT_FOR_RESUME;

            // Notify any threads waiting in onPause.
            this.notifyAll();

            while (mPause == PAUSE_WAIT_FOR_RESUME) {
                try {
                    this.wait();
                } catch (InterruptedException e) {
                }
            }
        }
        setOpenFile();
    }

    /**
     * if the activity was called with a file parameter, put it in the
     * 'PYTHON_OPENFILE' env var
     */
    public static void setOpenFile(){
        final android.content.Intent intent = mActivity.getIntent();
        if (intent != null) {
            final android.net.Uri data = intent.getData();
            if (data != null && data.getEncodedPath() != null){
                nativeSetEnv("PYTHON_OPENFILE", data.getEncodedPath());
            }
        }
    }

    /**
     * Inform the view that the activity is paused. The owner of this view must
     * call this method when the activity is paused. Calling this method will
     * pause the rendering thread.
     * Must not be called before a renderer has been set.
     */
    public void onPause() {
        synchronized (this) {
            if (mPause == PAUSE_NONE) {
                mPause = PAUSE_REQUEST;

                while (mPause == PAUSE_REQUEST) {
                    try {
                        this.wait();
                    } catch (InterruptedException e) {
                        // pass
                    }
                }
            }
        }

        if ( wakeLock != null )
            wakeLock.release();

    }

    /**
     * Inform the view that the activity is resumed. The owner of this view must
     * call this method when the activity is resumed. Calling this method will
     * recreate the OpenGL display and resume the rendering
     * thread.
     * Must not be called before a renderer has been set.
     */
    public void onResume() {
        synchronized (this) {
            if (mPause == PAUSE_WAIT_FOR_RESUME) {
                mPause = PAUSE_NONE;
                this.notifyAll();
            }
        }
        if ( wakeLock != null )
            wakeLock.acquire();
    }

    public void onDestroy() {
        Log.w(TAG, "onDestroy() called");
        synchronized (this) {
            this.notifyAll();

            if ( mPause == PAUSE_STOP_ACK ) {
                Log.d(TAG, "onDestroy() app already leaved.");
                return;
            }


            // application didn't leave, give 10s before closing.
            // hopefully, this could be enough for launching the on_stop() trigger within the app.
            mPause = PAUSE_STOP_REQUEST;
            int i = 50;

            Log.d(TAG, "onDestroy() stop requested, wait for an event from the app");
            for (; i >= 0 && mPause == PAUSE_STOP_REQUEST; i--) {
                try {
                    this.wait(200);
                } catch (InterruptedException e) {
                    break;
                }
            }
            Log.d(TAG, "onDestroy() stop finished waiting.");
        }
    }

    /**
     * This method is part of the SurfaceHolder.Callback interface, and is
     * not normally called or subclassed by clients of GLSurfaceView.
     */
    public void surfaceCreated(SurfaceHolder holder) {
        if (DEBUG) Log.d(TAG, "surfaceCreated()");
        synchronized (this) {
            if (!mStarted) {
                this.notifyAll();
            }
        }
    }

    /**
     * This method is part of the SurfaceHolder.Callback interface, and is
     * not normally called or subclassed by clients of GLSurfaceView.
     */
    public void surfaceDestroyed(SurfaceHolder holder) {
        if (DEBUG) Log.d(TAG, "surfaceDestroyed()");
    }

    /**
     * This method is part of the SurfaceHolder.Callback interface, and is
     * not normally called or subclassed by clients of GLSurfaceView.
     */
    public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {
        if (DEBUG) Log.i(TAG, String.format("surfaceChanged() fmt=%d size=%dx%d", format, w, h));

        if (!mRunning) {
            mRunning = true;
            new Thread(this).start();
        } else {
            mChanged = true;
        }
    }


    public void run() {
        waitForStart();
        
        nativeInitJavaCallbacks();
        nativeSetEnv("ANDROID_PRIVATE", mFilesDirectory);
        nativeSetEnv("ANDROID_ARGUMENT", mArgument);
        nativeSetEnv("PYTHONOPTIMIZE", "2");
        nativeSetEnv("PYTHONHOME", mFilesDirectory);
        nativeSetEnv("PYTHONPATH", mArgument + ":" + mFilesDirectory + "/lib");

        // XXX Using SetOpenFile make a crash in nativeSetEnv. I don't
        // understand why, maybe because the method is static or something.
        // Anyway, if you remove that part of the code, ensure the Laucher
        // (ProjectChooser) is still working.
        final android.content.Intent intent = mActivity.getIntent();
        if (intent != null) {
            final android.net.Uri data = intent.getData();
            if (data != null && data.getEncodedPath() != null)
                nativeSetEnv("PYTHON_OPENFILE", data.getEncodedPath());
        }

        nativeInit();

        mPause = PAUSE_STOP_ACK;

        Log.i(TAG, "End of native init, stop everything (exit0)");
        System.exit(0);
    }

    private void waitForStart() {
        // Wait to be notified it's okay to start Python.
        synchronized (this) {
            while (!mStarted) {
                try {
                    this.wait(250);
                } catch (InterruptedException e) {
                }
            }
        }
    }


    public void start() {
        synchronized (this) {
            mStarted = true;
            this.notify();
        }

    }

    //Necessary for nativeInitJavaCallbacks, so don't remove!
    public int swapBuffers() {
        // If the display has been changed, then disregard all the
        // rendering we've done to it.
        //
        // Otherwise, swap the buffers.
        if (mChanged) {
            return 0;

        } else {
            return 1;
        }

    }

    // Native part (Do not remove!)
    public static native void nativeSetEnv(String name, String value);
    public static native void nativeInit();

    public native void nativeExpose();
    public native void nativeInitJavaCallbacks();

}
